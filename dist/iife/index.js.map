{"version":3,"file":"index.js","sources":["../../node_modules/@isergeevv/html-grid-app-base/dist/esm/index.js"],"sourcesContent":["class ElementData {\n    constructor(element) {\n        this._element = element;\n    }\n    has(key) {\n        return this._element.hasAttribute(`data-${key}`);\n    }\n    get(key) {\n        return this._element.getAttribute(`data-${key}`);\n    }\n    set(key, value = '') {\n        this._element.setAttribute(`data-${key}`, value);\n    }\n    remove(key) {\n        this._element.removeAttribute(`data-${key}`);\n    }\n    toggle(key, value) {\n        if (value) {\n            this.set(key);\n        }\n        else {\n            this.remove(key);\n        }\n    }\n}\n\nclass GridAppGrid {\n    constructor(app, config) {\n        this._app = app;\n        this._element = document.createElement('div');\n        this._element.gridAppInstance = this;\n        this._gridElementConstructors = config.elements;\n        this._zoomConfig = config.zoom;\n        const appRect = app.element.getBoundingClientRect();\n        this._initialOffset = {\n            x: appRect.width / 2,\n            y: appRect.height / 2,\n        };\n        this._currentElementId = 1;\n        this.element.classList.add('app-grid');\n        this.element.style.setProperty('--gridapp-grid-size', config.size.toString());\n        this.element.style.setProperty('--gridapp-offset-x', this._initialOffset.x.toString());\n        this.element.style.setProperty('--gridapp-offset-y', this._initialOffset.y.toString());\n        this.element.style.setProperty('--gridapp-zoom', config.zoom.default.toString());\n        this._focusedComponent = null;\n        this._pointerInteractingElement = null;\n        this._modules = new Map();\n        for (const [moduleName, module] of Object.entries(config.modules)) {\n            const moduleObj = new module.constructor(this, module.config);\n            this._modules.set(moduleName, moduleObj);\n        }\n        this._data = new ElementData(this._element);\n        this.setActiveTool('grab');\n    }\n    get app() {\n        return this._app;\n    }\n    get element() {\n        return this._element;\n    }\n    get data() {\n        return this._data;\n    }\n    get gridElementConstructors() {\n        return this._gridElementConstructors;\n    }\n    get initialOffset() {\n        return this._initialOffset;\n    }\n    get pointerInteractingElement() {\n        return this._pointerInteractingElement;\n    }\n    get focusedComponent() {\n        return this._focusedComponent;\n    }\n    get zoom() {\n        return Number(this.element.style.getPropertyValue('--gridapp-zoom'));\n    }\n    get offset() {\n        return {\n            x: Number(this.element.style.getPropertyValue('--gridapp-offset-x')),\n            y: Number(this.element.style.getPropertyValue('--gridapp-offset-y')),\n        };\n    }\n    get isGridMoving() {\n        return this.data.get('moving') === 'grid';\n    }\n    get gridElements() {\n        return Array.from(this.element.querySelectorAll('.app-element')).map((el) => el.gridAppInstance);\n    }\n    get activeTool() {\n        let activeTool = this.data.get('active-tool');\n        if (!activeTool) {\n            activeTool = 'grab';\n            this._data.set('active-tool', activeTool);\n        }\n        return activeTool;\n    }\n    append(...elements) {\n        for (const element of elements) {\n            this._element.append(element.element);\n        }\n    }\n    setMoving(value) {\n        this._data.set('moving', value);\n    }\n    stopMoving() {\n        this._data.remove('moving');\n    }\n    getNextGridElementId() {\n        return this._currentElementId++;\n    }\n    createElement(type, label) {\n        const GridElementConstructor = this._gridElementConstructors.find((c) => c.type === type && c.label === label)?.constructor;\n        if (!GridElementConstructor) {\n            throw new Error(`No component type registered for type \"${type}\" and id \"${label}\".`);\n        }\n        const component = new GridElementConstructor(this);\n        component.setId(this.getNextGridElementId());\n        return component;\n    }\n    calculateMovePosition(viewPortMouseCoords, position) {\n        const zoom = this.zoom;\n        const delta = {\n            x: (this.app.lastMousePosition.x - viewPortMouseCoords.x) / zoom,\n            y: (this.app.lastMousePosition.y - viewPortMouseCoords.y) / zoom,\n        };\n        return {\n            x: position.x - delta.x,\n            y: position.y - delta.y,\n        };\n    }\n    setZoom(zoom) {\n        this.element.style.setProperty('--gridapp-zoom', zoom.toString());\n    }\n    updateZoom(moveDelta) {\n        const zoom = moveDelta * this._zoomConfig.step;\n        const currentZoom = this.zoom;\n        const newZoom = Math.min(this._zoomConfig.max, Math.max(this._zoomConfig.min, currentZoom + zoom));\n        this.setZoom(newZoom);\n    }\n    setOffset(offset) {\n        this.element.style.setProperty('--gridapp-offset-x', offset.x.toString());\n        this.element.style.setProperty('--gridapp-offset-y', offset.y.toString());\n    }\n    updateOffset(move) {\n        const offset = this.offset;\n        this.setOffset({\n            x: offset.x - move.x,\n            y: offset.y - move.y,\n        });\n    }\n    setPointerInteractingElement(element) {\n        this._pointerInteractingElement = element;\n    }\n    setFocusedComponent(component) {\n        if (this._focusedComponent) {\n            this._focusedComponent.toggleFocused(false);\n        }\n        this._focusedComponent = component;\n        if (this._focusedComponent) {\n            this._focusedComponent.toggleFocused(true);\n            let currentElement = this._focusedComponent.element;\n            while (currentElement.parentElement && currentElement.parentElement.closest('.app-grid')) {\n                currentElement.parentElement.append(currentElement);\n                currentElement = currentElement.parentElement;\n            }\n        }\n    }\n    setActiveTool(tool) {\n        this.data.set('active-tool', tool);\n    }\n    onMouseDown(e) {\n        const target = e.target;\n        if (!target.closest('.app-grid'))\n            return;\n        // fix for mouse up outside window\n        if (this._pointerInteractingElement) {\n            this._pointerInteractingElement.gridAppInstance.toggleMoving(false);\n            this._pointerInteractingElement = null;\n        }\n        for (const module of this._modules.values()) {\n            module.onMouseDown(e);\n        }\n        if (this.activeTool === 'grab' && this.pointerInteractingElement === null) {\n            this.setMoving('grid');\n            this.setFocusedComponent(null);\n        }\n    }\n    onMouseMove(e) {\n        const target = e.target;\n        if (!target.closest('.app-grid'))\n            return;\n        if (!this.app.mouseDown)\n            return;\n        for (const module of this._modules.values()) {\n            module.onMouseMove(e);\n        }\n        if (this.isGridMoving) {\n            const zoom = this.zoom;\n            this.updateOffset({\n                x: (this.app.lastMousePosition.x - e.clientX) / zoom,\n                y: (this.app.lastMousePosition.y - e.clientY) / zoom,\n            });\n        }\n    }\n    onMouseUp(e) {\n        const target = e.target;\n        if (!target.closest('.app-grid'))\n            return;\n        if (!this.app.mouseDown)\n            return;\n        for (const module of this._modules.values()) {\n            module.onMouseUp(e);\n        }\n        if (this.isGridMoving) {\n            this.stopMoving();\n        }\n        this.setPointerInteractingElement(null);\n    }\n    onClick(e) {\n        const target = e.target;\n        if (!target.closest('.app-grid'))\n            return;\n        for (const module of this._modules.values()) {\n            module.onClick(e);\n        }\n    }\n    onWheelMove(e) {\n        const target = e.target;\n        if (!target.closest('.app-grid'))\n            return;\n        this.updateZoom(e.deltaY < 0 ? 1 : -1);\n    }\n    onKeyDown(_e) { }\n    onKeyUp(_e) { }\n    onContextMenu(_e) { }\n    import(data) {\n        this._currentElementId = data.currentElementId;\n        this.setZoom(data.zoom);\n        this.setOffset(data.offset);\n        for (const elementData of data.elements) {\n            const component = this.createElement(elementData.type, elementData.label);\n            component.import(elementData);\n            this.element.append(component.element);\n        }\n    }\n    export() {\n        const currentElementId = this._currentElementId;\n        const zoom = this.zoom;\n        const offset = this.offset;\n        const elementsData = this.gridElements.map((component) => component.export());\n        const modulesData = {};\n        for (const [name, module] of this._modules.entries()) {\n            modulesData[name] = module.export();\n        }\n        return {\n            currentElementId: currentElementId,\n            zoom: zoom,\n            offset: offset,\n            elements: elementsData,\n            modules: modulesData,\n        };\n    }\n}\n\nconst isWithinRadius = (pos1, pos2, radius) => {\n    const dx = pos1.x - pos2.x;\n    const dy = pos1.y - pos2.y;\n    const distanceSquared = dx * dx + dy * dy;\n    return distanceSquared <= radius * radius;\n};\n\nclass GridApp {\n    constructor(appContainer, config) {\n        this._element = this._getAppContainerElement(appContainer);\n        this._element.classList.add('app-container');\n        this._events = new Map();\n        this._mouseDown = false;\n        this._lastMousePosition = { x: 0, y: 0 };\n        this._clickEventElement = null;\n        this._clickEventPosition = { x: 0, y: 0 };\n        this._grid = new GridAppGrid(this, config.grid);\n        this._element.append(this._grid.element);\n        this._modules = new Map();\n        for (const [moduleName, module] of Object.entries(config.modules)) {\n            const moduleObj = new module.constructor(this, module.config);\n            this._element.append(moduleObj.element);\n            this._modules.set(moduleName, moduleObj);\n        }\n        this._registerWindowEventListeners();\n    }\n    get element() {\n        return this._element;\n    }\n    get mouseDown() {\n        return this._mouseDown;\n    }\n    get lastMousePosition() {\n        return this._lastMousePosition;\n    }\n    get modules() {\n        return this._modules;\n    }\n    get events() {\n        return this._events;\n    }\n    get grid() {\n        return this._grid;\n    }\n    _getAppContainerElement(appContainer) {\n        if (typeof appContainer === 'string') {\n            appContainer = document.querySelector(appContainer);\n            if (!appContainer) {\n                throw new Error(`Element with selector \"${appContainer}\" not found.`);\n            }\n        }\n        return appContainer;\n    }\n    _registerWindowEventListeners() {\n        window.addEventListener('pointerdown', (e) => {\n            const target = e.target;\n            if (!target.closest('.app-container'))\n                return;\n            e.preventDefault();\n            this._grid.onMouseDown(e);\n            for (const module of this._modules.values()) {\n                module.onMouseDown(e);\n            }\n            this.setMouseDown();\n            this.setLastMousePosition({ x: e.clientX, y: e.clientY });\n            this._clickEventElement = target;\n            this._clickEventPosition = { x: e.clientX, y: e.clientY };\n        });\n        window.addEventListener('pointermove', (e) => {\n            const target = e.target;\n            if (!target.closest('.app-container'))\n                return;\n            e.preventDefault();\n            this._grid.onMouseMove(e);\n            for (const module of this._modules.values()) {\n                module.onMouseMove(e);\n            }\n            this.setLastMousePosition({ x: e.clientX, y: e.clientY });\n            if (this.grid.data.get('moving')) {\n                this._clickEventElement = null;\n            }\n        });\n        window.addEventListener('pointerup', (e) => {\n            const target = e.target;\n            e.preventDefault();\n            this._grid.onMouseUp(e);\n            for (const module of this._modules.values()) {\n                module.onMouseUp(e);\n            }\n            this.setMouseUp();\n            if (this._clickEventElement === target &&\n                isWithinRadius(this._clickEventPosition, { x: e.clientX, y: e.clientY }, 5)) {\n                this._grid.onClick(e);\n                for (const module of this._modules.values()) {\n                    module.onClick(e);\n                }\n            }\n        });\n        window.addEventListener('wheel', (e) => {\n            const target = e.target;\n            if (!target.closest('.app-container'))\n                return;\n            e.preventDefault();\n            this._grid.onWheelMove(e);\n            for (const module of this._modules.values()) {\n                module.onWheelMove(e);\n            }\n        }, { passive: false });\n        window.addEventListener('keydown', (e) => {\n            const target = e.target;\n            if (!target.closest('.app-container'))\n                return;\n            e.preventDefault();\n            this._grid.onKeyDown(e);\n            for (const module of this._modules.values()) {\n                module.onKeyDown(e);\n            }\n        });\n        window.addEventListener('keyup', (e) => {\n            const target = e.target;\n            if (!target.closest('.app-container'))\n                return;\n            e.preventDefault();\n            this._grid.onKeyUp(e);\n            for (const module of this._modules.values()) {\n                module.onKeyUp(e);\n            }\n        });\n        window.addEventListener('contextmenu', (e) => {\n            const target = e.target;\n            if (!target.closest('.app-container'))\n                return;\n            e.preventDefault();\n            this._grid.onContextMenu(e);\n            for (const module of this._modules.values()) {\n                module.onContextMenu(e);\n            }\n        });\n    }\n    setMouseDown() {\n        this._mouseDown = true;\n    }\n    setLastMousePosition(position) {\n        this._lastMousePosition = position;\n    }\n    setMouseUp() {\n        this._mouseDown = false;\n    }\n    import(data) {\n        for (const [moduleName, moduleData] of Object.entries(data.modules)) {\n            const module = this._modules.get(moduleName);\n            if (!module) {\n                throw new Error(`Module \"${moduleName}\" is not registered.`);\n            }\n            module.import(moduleData);\n        }\n    }\n    export() {\n        const modulesData = {};\n        for (const [moduleName, module] of this._modules.entries()) {\n            modulesData[moduleName] = module.export();\n        }\n        return {\n            grid: this._grid.export(),\n            modules: modulesData,\n        };\n    }\n}\n\nclass GridAppModule {\n    constructor(app, config) {\n        this._app = app;\n        this._element = document.createElement('div');\n        this._element.gridAppInstance = this;\n        this._data = new ElementData(this._element);\n        this.element.classList.add('app-module');\n        this.element.dataset['label'] = config.label;\n    }\n    get app() {\n        return this._app;\n    }\n    get element() {\n        return this._element;\n    }\n    get data() {\n        return this._data;\n    }\n    get label() {\n        const label = this._data.get('label');\n        if (!label) {\n            throw new Error('Module label is not set.');\n        }\n        return label;\n    }\n}\n\nclass GridAppGridElement {\n    constructor(grid, config) {\n        this._grid = grid;\n        this._element = document.createElement('div');\n        this._element.gridAppInstance = this;\n        this._data = new ElementData(this._element);\n        this._data.set('type', config.type);\n        this._data.set('label', config.label);\n        this.setPosition({ x: 0, y: 0 });\n        this.setMinSize({ w: 0, h: 0 });\n        this.setSize({ w: 0, h: 0 });\n        this.setBackgroundColor(config.defaultBackgroundColor);\n        this.setTextColor(config.defaultTextColor);\n    }\n    get element() {\n        return this._element;\n    }\n    get parentElement() {\n        const parentElement = this._element.parentElement;\n        if (!parentElement) {\n            throw new Error('Element has no parent element.');\n        }\n        return parentElement;\n    }\n    get parent() {\n        if (this.parentElement.gridAppInstance instanceof GridAppGrid) {\n            return this.parentElement.gridAppInstance;\n        }\n        return this.parentElement.gridAppInstance.component;\n    }\n    get data() {\n        return this._data;\n    }\n    get type() {\n        const type = this._data.get('type');\n        if (!type) {\n            throw new Error('Element type is not set.');\n        }\n        return type;\n    }\n    get label() {\n        const label = this._data.get('label');\n        if (!label) {\n            throw new Error('Element label is not set.');\n        }\n        return label;\n    }\n    get id() {\n        const id = this._data.get('id');\n        if (!id) {\n            throw new Error('Element id is not set.');\n        }\n        return Number(id);\n    }\n    get grid() {\n        return this._grid;\n    }\n    get position() {\n        return {\n            x: Number(this._element.style.getPropertyValue('--gridapp-element-x')),\n            y: Number(this._element.style.getPropertyValue('--gridapp-element-y')),\n        };\n    }\n    get minSize() {\n        return {\n            w: Number(this._element.style.getPropertyValue('--gridapp-element-min-w')),\n            h: Number(this._element.style.getPropertyValue('--gridapp-element-min-h')),\n        };\n    }\n    get size() {\n        return {\n            w: Number(this._element.style.getPropertyValue('--gridapp-element-w')),\n            h: Number(this._element.style.getPropertyValue('--gridapp-element-h')),\n        };\n    }\n    get isMoving() {\n        return this._data.has('moving');\n    }\n    get backgroundColor() {\n        const bgColor = this._element.style.getPropertyValue('--gridapp-element-bg-color');\n        return bgColor.split(',').map(Number);\n    }\n    get textColor() {\n        const textColor = this._element.style.getPropertyValue('--gridapp-element-text-color');\n        return textColor.split(',').map(Number);\n    }\n    toggleMoving(value) {\n        this._data.toggle('moving', value);\n    }\n    setMinSize(size) {\n        this._element.style.setProperty('--gridapp-element-min-w', size.w.toString());\n        this._element.style.setProperty('--gridapp-element-min-h', size.h.toString());\n    }\n    setSize(size) {\n        this._element.style.setProperty('--gridapp-element-w', size.w.toString());\n        this._element.style.setProperty('--gridapp-element-h', size.h.toString());\n    }\n    setId(value) {\n        this._data.set('id', value.toString());\n    }\n    setPosition(position) {\n        this._element.style.setProperty('--gridapp-element-x', position.x.toString());\n        this._element.style.setProperty('--gridapp-element-y', position.y.toString());\n    }\n    setBackgroundColor(color) {\n        this._element.style.setProperty('--gridapp-element-bg-color', color.join(', '));\n    }\n    setTextColor(color) {\n        this._element.style.setProperty('--gridapp-element-text-color', color.join(', '));\n    }\n}\n\nclass GridAppGridModule {\n    constructor(grid, config) {\n        this._grid = grid;\n        this._element = document.createElement('div');\n        this._element.gridAppInstance = this;\n        this.element.classList.add('app-module');\n        this.element.dataset['label'] = config.label;\n    }\n    get grid() {\n        return this._grid;\n    }\n    get element() {\n        return this._element;\n    }\n    get label() {\n        const label = this._element.dataset['label'];\n        if (!label) {\n            throw new Error('Module label is not set.');\n        }\n        return label;\n    }\n    calculateMovePosition(viewPortMouseCoords, position) {\n        const zoom = this.grid.zoom;\n        const delta = {\n            x: (this.grid.app.lastMousePosition.x - viewPortMouseCoords.x) / zoom,\n            y: (this.grid.app.lastMousePosition.y - viewPortMouseCoords.y) / zoom,\n        };\n        return {\n            x: position.x - delta.x,\n            y: position.y - delta.y,\n        };\n    }\n}\n\nclass GridAppGridComponents extends GridAppGridModule {\n    constructor(grid, config) {\n        super(grid, config);\n        this._collisionConfig = config.collision || {};\n    }\n    _getCollisionComponents(component) {\n        const id = component.id;\n        const label = component.label;\n        return this.grid.gridElements.filter((c) => c.type === 'component' &&\n            c.id !== id &&\n            this._collisionConfig[label] &&\n            (this._collisionConfig[label].length === 0 || this._collisionConfig[label].includes(c.label)));\n    }\n    _getPositionsOverlap(position1, size1, position2, size2) {\n        if (position1.x < position2.x + size2.w &&\n            position1.x + size1.w > position2.x &&\n            position1.y < position2.y + size2.h &&\n            position1.y + size1.h > position2.y) {\n            return true;\n        }\n        return false;\n    }\n    _detectCollision(component, movePosition) {\n        const componentSize = component.size;\n        const componentPosition = component.position;\n        const collisionComponents = this._getCollisionComponents(component);\n        for (const collisionComponent of collisionComponents) {\n            const collisionComponentPosition = collisionComponent.position;\n            const collisionComponentSize = collisionComponent.size;\n            if (this._getPositionsOverlap(movePosition, componentSize, collisionComponentPosition, collisionComponentSize) &&\n                !this._getPositionsOverlap(componentPosition, componentSize, collisionComponentPosition, collisionComponentSize)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    onMouseDown(e) {\n        const target = e.target;\n        const componentElement = target.closest('[data-type=\"component\"]');\n        if (componentElement) {\n            componentElement.gridAppInstance.onMouseDown(e);\n            this.grid.setFocusedComponent(componentElement.gridAppInstance);\n        }\n    }\n    onMouseMove(e) {\n        const element = this.grid.pointerInteractingElement;\n        if (element === null)\n            return;\n        if (element.dataset['type'] !== 'component')\n            return;\n        const componentElement = element;\n        const viewPortMouseCoords = {\n            x: e.clientX,\n            y: e.clientY,\n        };\n        const componentPosition = componentElement.gridAppInstance.position;\n        const movePosition = this.calculateMovePosition(viewPortMouseCoords, componentPosition);\n        if (!this._detectCollision(componentElement.gridAppInstance, movePosition)) {\n            componentElement.gridAppInstance.onMouseMove(e);\n        }\n    }\n    onMouseUp(e) {\n        const element = this.grid.pointerInteractingElement;\n        if (element === null)\n            return;\n        if (element.dataset['type'] !== 'component')\n            return;\n        const componentElement = element;\n        componentElement.gridAppInstance.onMouseUp(e);\n    }\n    onClick(_e) { }\n    onWheelMove(_e) { }\n    onKeyDown(_e) { }\n    onKeyUp(_e) { }\n    import(_data) { }\n    export() {\n        return {};\n    }\n}\n\nclass GridAppGridConnections extends GridAppGridModule {\n    constructor(grid, config) {\n        super(grid, config);\n        const connectionTypes = Object.keys(this.grid.gridElementConstructors.filter((c) => c.type === 'connection'));\n        if (connectionTypes.length === 0) {\n            throw new Error('No connection types registered.');\n        }\n        this._currentConnectionType = connectionTypes[0];\n    }\n    get currentConnectionType() {\n        return this._currentConnectionType;\n    }\n    onMouseDown(e) {\n        const target = e.target;\n        const connectionElement = target.closest('[data-type=\"connection\"]');\n        if (connectionElement) {\n            connectionElement.gridAppInstance.onMouseDown(e);\n            return;\n        }\n        const componentConnectorElement = target.closest('.app-component-connector[data-connector-type=\"output\"]');\n        if (componentConnectorElement) {\n            componentConnectorElement.gridAppInstance.onMouseDown(e);\n        }\n    }\n    onMouseMove(e) {\n        const element = this.grid.pointerInteractingElement;\n        if (element === null)\n            return;\n        if (element.dataset['type'] !== 'connection')\n            return;\n        const connectionElement = element;\n        connectionElement.gridAppInstance.onMouseMove(e);\n    }\n    onMouseUp(e) {\n        const element = this.grid.pointerInteractingElement;\n        if (element === null)\n            return;\n        if (element.dataset['type'] !== 'connection')\n            return;\n        const connectionElement = element;\n        connectionElement.gridAppInstance.onMouseUp(e);\n    }\n    onClick(_e) { }\n    onWheelMove(_e) { }\n    onKeyDown(_e) { }\n    onKeyUp(_e) { }\n    import(_data) { }\n    export() {\n        return {};\n    }\n}\n\nvar CONNECTOR_TYPES;\n(function (CONNECTOR_TYPES) {\n    CONNECTOR_TYPES[\"INPUT\"] = \"input\";\n    CONNECTOR_TYPES[\"OUTPUT\"] = \"output\";\n})(CONNECTOR_TYPES || (CONNECTOR_TYPES = {}));\nvar RESIZE_TYPES;\n(function (RESIZE_TYPES) {\n    RESIZE_TYPES[\"LEFT\"] = \"left\";\n    RESIZE_TYPES[\"RIGHT\"] = \"right\";\n    RESIZE_TYPES[\"TOP\"] = \"top\";\n    RESIZE_TYPES[\"BOTTOM\"] = \"bottom\";\n})(RESIZE_TYPES || (RESIZE_TYPES = {}));\n\nclass GridAppComponentContainer {\n    constructor(grid, _config) {\n        this._grid = grid;\n        this._element = document.createElement('div');\n        this._element.gridAppInstance = this;\n        this._element.classList.add(`app-component-container`);\n    }\n    get element() {\n        return this._element;\n    }\n    get grid() {\n        return this._grid;\n    }\n    get component() {\n        const componentElement = this._element.closest('.app-element[data-type=\"component\"]');\n        if (!componentElement) {\n            throw new Error('No grid component found for connector.');\n        }\n        return componentElement.gridAppInstance;\n    }\n}\n\nclass GridAppComponent extends GridAppGridElement {\n    constructor(grid, config) {\n        super(grid, config);\n        this.element.classList.add('app-element');\n        this.setMinSize(config.minSize);\n        this.setSize(config.size);\n        if (config.resize.length > 0) {\n            const resizeElements = this._generateResizeElements(config.resize);\n            this.element.append(...resizeElements);\n        }\n        if (config.container) {\n            const container = new GridAppComponentContainer(this.grid, {});\n            this.element.append(container.element);\n        }\n    }\n    get isResizing() {\n        return this.data.has('resizing');\n    }\n    get isFocused() {\n        return this.data.has('focused');\n    }\n    get resizingType() {\n        const resizingType = this.data.get('resizing');\n        if (!resizingType) {\n            throw new Error('Resizing type is not set.');\n        }\n        return resizingType;\n    }\n    get containerElement() {\n        return this.element.querySelector('.app-component-container');\n    }\n    get container() {\n        const containerElement = this.containerElement;\n        if (!containerElement) {\n            return null;\n        }\n        return containerElement.gridAppInstance;\n    }\n    _generateResizeElements(resizeConfig) {\n        const resizeElements = [];\n        for (const resizeType of resizeConfig) {\n            const resizeElement = document.createElement('div');\n            resizeElement.classList.add('app-component-resize');\n            resizeElement.dataset['resizeType'] = resizeType;\n            resizeElements.push(resizeElement);\n        }\n        return resizeElements;\n    }\n    _checkPositionInContainerBounds(position) {\n        const parent = this.parent;\n        console.log(parent);\n        if (!(parent instanceof GridAppComponent)) {\n            return true;\n        }\n        const container = parent.container;\n        console.log(container);\n        if (!container) {\n            return true;\n        }\n        const componentSize = this.size;\n        const containerRect = container.element.getBoundingClientRect();\n        console.log('Container Rect:', containerRect);\n        console.log('Position to check:', position);\n        return (position.x >= 0 &&\n            position.x + componentSize.w <= containerRect.width &&\n            position.y >= 0 &&\n            position.y + componentSize.h <= containerRect.height);\n    }\n    toggleFocused(value) {\n        this.data.toggle('focused', value);\n    }\n    setResizing(value) {\n        this.data.set('resizing', value);\n    }\n    stopResizing() {\n        this.data.remove('resizing');\n    }\n    moveConnectionElements(delta) {\n        const id = this.id;\n        const startConnectionElements = this.grid.element.querySelectorAll(`[data-type=\"connection\"][data-start-anchor-id=\"${id}\"]`);\n        for (const connectionElement of startConnectionElements) {\n            const gridAppConnection = connectionElement.gridAppInstance;\n            const connectionStartPosition = gridAppConnection.position;\n            const connectionEndPosition = gridAppConnection.endPosition;\n            gridAppConnection.setPosition({\n                x: connectionStartPosition.x - delta.x,\n                y: connectionStartPosition.y - delta.y,\n            });\n            gridAppConnection.generateConnectionPath(connectionEndPosition);\n        }\n        const endConnectionElements = this.grid.element.querySelectorAll(`[data-type=\"connection\"][data-end-anchor-id=\"${id}\"]`);\n        for (const connectionElement of endConnectionElements) {\n            const gridAppConnection = connectionElement.gridAppInstance;\n            const connectionEndPosition = gridAppConnection.endPosition;\n            gridAppConnection.generateConnectionPath({\n                x: connectionEndPosition.x - delta.x,\n                y: connectionEndPosition.y - delta.y,\n            });\n        }\n    }\n    move(e) {\n        const zoom = this.grid.zoom;\n        const position = this.position;\n        const delta = {\n            x: (this.grid.app.lastMousePosition.x - e.clientX) / zoom,\n            y: (this.grid.app.lastMousePosition.y - e.clientY) / zoom,\n        };\n        const newPosition = {\n            x: position.x - delta.x,\n            y: position.y - delta.y,\n        };\n        if (this._checkPositionInContainerBounds(newPosition)) {\n            this.setPosition(newPosition);\n            this.moveConnectionElements(delta);\n        }\n    }\n    resize(e) {\n        const zoom = this.grid.zoom;\n        const position = this.position;\n        const resizingType = this.resizingType;\n        const size = this.size;\n        const minSize = this.minSize;\n        const delta = {\n            x: (this.grid.app.lastMousePosition.x - e.clientX) / zoom,\n            y: (this.grid.app.lastMousePosition.y - e.clientY) / zoom,\n        };\n        switch (resizingType) {\n            case RESIZE_TYPES.LEFT:\n                if (size.w + delta.x < minSize.w) {\n                    delta.x = minSize.w - size.w;\n                }\n                this.setSize({ w: size.w + delta.x, h: size.h });\n                this.setPosition({ x: position.x - delta.x, y: position.y });\n                break;\n            case RESIZE_TYPES.RIGHT:\n                this.setSize({ w: size.w - delta.x, h: size.h });\n                break;\n            case RESIZE_TYPES.TOP:\n                if (size.h + delta.y < minSize.h) {\n                    delta.y = minSize.h - size.h;\n                }\n                this.setSize({ w: size.w, h: size.h + delta.y });\n                this.setPosition({ x: position.x, y: position.y - delta.y });\n                break;\n            case RESIZE_TYPES.BOTTOM:\n                this.setSize({ w: size.w, h: size.h - delta.y });\n                break;\n            default:\n                throw new Error(`Invalid resize type: ${resizingType}`);\n        }\n        this.moveConnectionElements(delta);\n    }\n    onMouseDown(e) {\n        const target = e.target;\n        switch (this.grid.activeTool) {\n            case 'grab': {\n                this.grid.setPointerInteractingElement(this.element);\n                this.toggleMoving(true);\n                this.grid.setMoving('element');\n                break;\n            }\n            case 'resize': {\n                if (target.classList.contains('app-component-resize')) {\n                    const resizeType = target.dataset['resizeType'];\n                    if (!resizeType) {\n                        throw new Error('Resize type is not set.');\n                    }\n                    this.grid.setPointerInteractingElement(this.element);\n                    this.setResizing(resizeType);\n                }\n                break;\n            }\n        }\n    }\n    onMouseMove(e) {\n        if (this.isMoving) {\n            this.move(e);\n        }\n        else if (this.isResizing) {\n            this.resize(e);\n        }\n    }\n    onMouseUp(e) {\n        const target = e.target;\n        const targetComponentContainerElement = target.closest('.app-element[data-type=\"component\"] > .app-component-container');\n        if (targetComponentContainerElement) {\n            const componentElement = targetComponentContainerElement.closest('.app-element[data-type=\"component\"]');\n            if (!componentElement) {\n                throw new Error('Component element not found.');\n            }\n            if (this.parentElement !== targetComponentContainerElement) {\n                const component = componentElement.gridAppInstance;\n                if (confirm(`Place ${this.type} component inside this ${component.type} component container?`)) {\n                    targetComponentContainerElement.append(this.element);\n                    this.setPosition({ x: 0, y: 0 });\n                }\n            }\n        }\n        this.toggleMoving(false);\n        this.grid.stopMoving();\n        this.stopResizing();\n    }\n    onClick(_e) { }\n    onWheelMove(_e) { }\n    onKeyDown(_e) { }\n    onKeyUp(_e) { }\n}\n\nclass GridAppConnection extends GridAppGridElement {\n    constructor(grid, config) {\n        super(grid, config);\n        this.element.classList.add('app-element');\n        this.element.dataset['startAnchorId'] = '0';\n        this.element.dataset['endAnchorId'] = '0';\n        this.element.style.setProperty('--x2', '0');\n        this.element.style.setProperty('--y2', '0');\n        this.element.style.setProperty('--deg', '0');\n    }\n    get startAnchorId() {\n        return Number(this.element.dataset['startAnchorId']);\n    }\n    get endAnchorId() {\n        return Number(this.element.dataset['endAnchorId']);\n    }\n    get distance() {\n        return Number(this.element.style.getPropertyValue('--dist'));\n    }\n    get endPosition() {\n        return {\n            x: Number(this.element.style.getPropertyValue('--x2')),\n            y: Number(this.element.style.getPropertyValue('--y2')),\n        };\n    }\n    setDegree(deg) {\n        this.element.style.setProperty('--deg', deg.toString());\n    }\n    getDegree() {\n        return Number(this.element.style.getPropertyValue('--deg'));\n    }\n    setDistance(distance) {\n        this.element.style.setProperty('--dist', distance.toString());\n    }\n    setEndPosition(position) {\n        this.element.style.setProperty('--x2', position.x.toString());\n        this.element.style.setProperty('--y2', position.y.toString());\n    }\n    setStartAnchorId(id) {\n        this.element.dataset['startAnchorId'] = id.toString();\n    }\n    setEndAnchorId(id) {\n        this.element.dataset['endAnchorId'] = id.toString();\n    }\n    onMouseDown(e) {\n        const zoom = this.grid.zoom;\n        const offset = this.grid.offset;\n        const initialOffset = this.grid.initialOffset;\n        this.setEndAnchorId(0);\n        this.generateConnectionPath({\n            x: (e.clientX - initialOffset.x) / zoom + initialOffset.x - offset.x,\n            y: (e.clientY - initialOffset.y) / zoom + initialOffset.y - offset.y,\n        });\n        this.grid.setPointerInteractingElement(this.element);\n        this.toggleMoving(true);\n    }\n    onMouseMove(e) {\n        const zoom = this.grid.zoom;\n        const offset = this.grid.offset;\n        const initialOffset = this.grid.initialOffset;\n        this.generateConnectionPath({\n            x: (e.clientX - initialOffset.x) / zoom + initialOffset.x - offset.x,\n            y: (e.clientY - initialOffset.y) / zoom + initialOffset.y - offset.y,\n        });\n    }\n    onMouseUp(e) {\n        const target = e.target;\n        const pointedElement = target.closest('.app-component-connector[data-connector-type=\"input\"]');\n        if (pointedElement && pointedElement.gridAppInstance.component.id !== this.startAnchorId) {\n            const zoom = this.grid.zoom;\n            const offset = this.grid.offset;\n            const initialOffset = this.grid.initialOffset;\n            this.generateConnectionPath({\n                x: (e.clientX - initialOffset.x) / zoom + initialOffset.x - offset.x,\n                y: (e.clientY - initialOffset.y) / zoom + initialOffset.y - offset.y,\n            });\n            this.setEndAnchorId(pointedElement.gridAppInstance.component.id);\n            this.toggleMoving(false);\n        }\n        else {\n            this.element.parentElement.removeChild(this.element);\n        }\n    }\n    onClick(_e) { }\n    onWheelMove(_e) { }\n    onKeyDown(_e) { }\n    onKeyUp(_e) { }\n}\n\nclass GridAppComponentConnector {\n    constructor(grid, config) {\n        this._grid = grid;\n        this._element = document.createElement('div');\n        this._element.gridAppInstance = this;\n        this._element.classList.add(`app-component-connector`);\n        this._element.dataset['label'] = config.label;\n        this._element.dataset['connectorType'] = config.connectorType;\n    }\n    get element() {\n        return this._element;\n    }\n    get grid() {\n        return this._grid;\n    }\n    get component() {\n        const gridComponentElement = this._element.closest('.app-element[data-type=\"component\"]');\n        if (!gridComponentElement) {\n            throw new Error('No grid component found for connector.');\n        }\n        return gridComponentElement.gridAppInstance;\n    }\n    get label() {\n        const label = this._element.dataset['label'];\n        if (!label) {\n            throw new Error('Connector label is not set.');\n        }\n        return label;\n    }\n    get connectorType() {\n        const type = this._element.dataset['connectorType'];\n        if (!type) {\n            throw new Error('Connector type is not set.');\n        }\n        return type;\n    }\n    onMouseDown(e) {\n        const zoom = this.grid.zoom;\n        const offset = this.grid.offset;\n        const connection = this.grid.createElement('connection', 'line');\n        connection.setStartAnchorId(this.component.id);\n        this.grid.append(connection);\n        connection.setPosition({\n            x: (e.clientX - this.grid.initialOffset.x) / zoom + this.grid.initialOffset.x - offset.x,\n            y: (e.clientY - this.grid.initialOffset.y) / zoom + this.grid.initialOffset.y - offset.y,\n        });\n        this.grid.setPointerInteractingElement(connection.element);\n        connection.toggleMoving(true);\n        return true;\n    }\n    onConnectionStart() {\n        // Implement connection start logic if needed\n        console.log(`Connection started for connector: ${this.label}`);\n    }\n    onConnectionEnd() {\n        // Implement connection end logic if needed\n        console.log(`Connection ended for connector: ${this.label}`);\n    }\n}\n\nclass GridAppLineConnection extends GridAppConnection {\n    constructor(grid) {\n        super(grid, {\n            type: 'connection',\n            label: 'line',\n            defaultBackgroundColor: [255, 0, 0],\n            defaultTextColor: [0, 0, 0],\n        });\n    }\n    generateConnectionPath(endPosition) {\n        this.setEndPosition(endPosition);\n        const startPosition = this.position;\n        const deg = this._calcRotateDeg(startPosition, endPosition);\n        const distance = this._calcDistance(startPosition, endPosition);\n        this.setDegree(deg);\n        this.setDistance(distance);\n    }\n    _calcRotateDeg(pos1, pos2) {\n        const x = pos2.x - pos1.x;\n        const y = pos2.y - pos1.y;\n        const angle = Math.atan2(x, y);\n        const deg = -angle * (180 / Math.PI);\n        return deg;\n    }\n    _calcDistance(pos1, pos2) {\n        const x = (pos2.x - pos1.x) ** 2;\n        const y = (pos2.y - pos1.y) ** 2;\n        return Math.sqrt(x + y);\n    }\n    import(data) {\n        this.setPosition(data.position);\n        this.setEndPosition(data.endPosition);\n        this.setDegree(this._calcRotateDeg(data.position, data.endPosition));\n        this.setStartAnchorId(data.startAnchorId);\n        this.setEndAnchorId(data.endAnchorId);\n        this.setBackgroundColor(data.backgroundColor);\n        this.setTextColor(data.textColor);\n    }\n    export() {\n        const id = this.id;\n        const type = this.type;\n        const label = this.label;\n        const startAnchorId = this.startAnchorId;\n        const endAnchorId = this.endAnchorId;\n        const position = this.position;\n        const endPosition = this.endPosition;\n        const size = this.size;\n        const backgroundColor = this.backgroundColor;\n        const textColor = this.textColor;\n        return {\n            id: id,\n            type: type,\n            label: label,\n            startAnchorId: startAnchorId,\n            endAnchorId: endAnchorId,\n            position: { x: position.x, y: position.y },\n            endPosition: { x: endPosition.x, y: endPosition.y },\n            size: size,\n            backgroundColor: backgroundColor,\n            textColor: textColor,\n        };\n    }\n}\n\nexport { CONNECTOR_TYPES, GridApp, GridAppComponent, GridAppComponentConnector, GridAppComponentContainer, GridAppConnection, GridAppGrid, GridAppGridComponents, GridAppGridConnections, GridAppGridElement, GridAppGridModule, GridAppLineConnection, GridAppModule, RESIZE_TYPES };\n"],"names":[],"mappings":"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","x_google_ignoreList":[0]}